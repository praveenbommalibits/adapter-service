# ADCB Microservices Developer Guidelines

## Document Overview

### Purpose
This comprehensive guide establishes development standards for ADCB's microservices transformation initiative, covering all aspects from repository management to production deployment.

### Scope
Applies to all backend services, shared libraries, and infrastructure components developed by 50+ developers across multiple teams.

### Target Audience
Software developers, tech leads, solution architects, DevOps engineers, and platform teams.

---

## 1. GitHub & Version Control Guidelines

### 1.1 Repository Management

#### Repository Naming Standards
- **Microservices**: `mib-{domain}-{capability}-svc`
  - Example: `customer-profile-svc`, `payments-statement-svc`
- **Libraries**: `mib-{library-name}-lib`
  - Example: `mib-common-utils-lib`, `mib-security-jwt-lib`
- **Infrastructure**: `{component}-infra`
  - Example: `eks-cluster-infra`, `monitoring-infra`

#### Repository Structure
All repositories must include:
- `README.md` with comprehensive setup instructions
- `LICENSE` file (Apache 2.0 or proprietary)
- `.gitignore` with Java/Gradle/IntelliJ defaults
- `.editorconfig` for consistent formatting
- `CODEOWNERS` defining required reviewers
- `.github/pull_request_template.md`

#### Visibility & Access Control
- Default: Private repositories
- Internal/public requires architecture team approval
- Branch protection rules enforced on `main`/`develop`
- Required status checks before merge

### 1.2 Branching Strategy

#### Branch Model (GitFlow-Lite)
- **main**: Production-ready code only
  - Protected branch requiring 2 approvals
  - Automatic deployment to production
  - All commits must be signed
- **develop**: Integration branch
  - Protected branch requiring 1 approval
  - Continuous integration testing
  - Automatic deployment to development environment
- **Feature branches**: `feature/JIRA-{number}-{description}`
  - Short-lived (max 2 weeks)
  - Regular rebase from develop
- **Bug fixes**: `bugfix/JIRA-{number}-{description}`
- **Hotfixes**: `hotfix/JIRA-{number}-{description}`

#### Commit Standards
- Use Conventional Commits format
  - `feat`: new features
  - `fix`: bug fixes
  - `chore`: maintenance tasks
  - `docs`: documentation updates
- Include Jira ticket reference
- Descriptive commit messages

### 1.3 Pull Request Process

#### PR Requirements
- Title format: `[JIRA-123] Brief description`
- Complete PR template checklist
- Minimum reviewers: 1 for develop, 2 for main
- All CI checks must pass (build, tests, security)
- No merge conflicts

#### Code Review Guidelines
- Focus on business logic correctness
- Verify coding standards compliance
- Check test coverage (minimum 70%)
- Security review for sensitive changes
- Performance impact assessment

---

## 2. Microservice Development Guidelines

### 2.1 Service Design Principles

#### Domain-Driven Design
- Each service represents single bounded context
- Business capability alignment
- Independent data ownership
- Autonomous deployment capability

#### Service Naming
- Format: `mib-{domain}-{capability}-svc`
- Examples:
  - `mib-user-registration-svc`
  - `mib-payment-svc`
  - `mib-tech-proxy-svc`
  - `mib-risk-assessment-svc`

### 2.2 Architecture Patterns

#### Hexagonal Architecture
- **Ports & Adapters pattern implementation**
- Clear separation of business logic from infrastructure
- Testable and maintainable code structure

#### API Design
- RESTful conventions
- Base path: `/api/v{version}/{resource}` //TODO to be concluded
- Resource-oriented URLs (nouns, not verbs)
- Consistent HTTP status codes
- OpenAPI 3.0 specification mandatory

### 2.3 Technology Stack Standards

#### Core Technologies
- Java 21LTS (minimum)
- Spring Boot 3.5.x
- Gradle with Kotlin DSL
- Docker containerization

#### Database Technologies
- Primary: PostgreSQL (Amazon Aurora)
- Legacy: Oracle (migration path defined)
- Caching: Redis
- Message Queues: Apache Kafka

---

## 3. Java Code Standards

### 3.1 Package Structure

#### Microservice Package Hierarchy
```
com.adcb.{domain}.{capability}
// TODO: sample microservice template will be provided
```

#### Common Library Package Structure
```
org.adcb.{library}
```

### 3.2 Coding Conventions

#### Class Naming
- UpperCamelCase for classes and interfaces
- Descriptive names reflecting business purpose
- Avoid abbreviations and technical jargon

#### Method Naming
- lowerCamelCase for methods and variables
- Verb-noun combinations for methods
- Boolean methods start with "is", "has", "can"

#### Constants
- UPPER_SNAKE_CASE for constants
- Group related constants in enums or interfaces

---

## 4. EditorConfig & Code Formatting

### 4.1 Standard .editorconfig
TODO: refer the attached editorconfig file and README section on the same

### 4.2 IDE Integration

#### IntelliJ IDEA Setup
- Enable EditorConfig support
- Configure "Format on Save"
- Optimize imports on save
- Install Checkstyle-IDEA plugin

### 4.3 Enforcement
- Pre-commit hooks for validation
- CI pipeline fails on formatting violations
- Spotless Gradle plugin integration

---

## 5. Gradle Project Setup

### 5.1 Build Script Standards

#### Gradle Wrapper
- Always use Gradle wrapper (`./gradlew`)
- Pin to specific Gradle version
- Commit wrapper files to repository

#### Kotlin DSL
- Use `build.gradle.kts` over Groovy
- Type-safe build configuration
- Better IDE support and refactoring

### 5.2 Project Structure

#### Multi-Module Projects
```
project-root/
â”œâ”€â”€ gradle/               (wrapper files)
â”œâ”€â”€ src/main/java/        (source code)
â”œâ”€â”€ src/test/java/        (test code)
â”œâ”€â”€ build.gradle.kts
â”œâ”€â”€ settings.gradle.kts
â”œâ”€â”€ gradle.properties
â””â”€â”€ README.md
```

### 5.3 Plugin Configuration

#### Standard Plugins
- Spring Boot plugin
- Spring Dependency Management
- Spotless (code formatting)
- JaCoCo (test coverage)
- Docker plugin

#### Quality Gates
- Minimum 70% test coverage
- Zero high-severity Spotbugs issues
- Checkstyle compliance
- Security vulnerability scanning

---

## 6. Dependency Management & BOM

### 6.1 BOM Strategy

#### Central BOM Repository
- Repository: `mib-dependencies-bom`
- Manages all dependency versions
- Published to GitHub Packages
- Quarterly release cycle

#### BOM Structure
```
org.adcb:adcb-dependencies-bom:2024.4.0
â”œâ”€â”€ Spring Boot (managed versions)
â”œâ”€â”€ Spring Cloud (managed versions)
â”œâ”€â”€ Database drivers
â”œâ”€â”€ Testing frameworks
â”œâ”€â”€ Security libraries
â””â”€â”€ ADCB internal libraries
```

### 6.2 BOM Usage

#### In Microservices
```groovy
dependencyManagement {
    imports {
        mavenBom("org.adcb:adcb-dependencies-bom:2024.4.0")
    }
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    // No version needed - managed by BOM
}
```

### 6.3 BOM Governance

#### Version Management
- Platform team maintains BOM
- Security updates prioritized
- Breaking change communication process
- Migration guides for major updates

#### Approval Process
- New dependencies require architecture review
- Version updates tested in staging environment
- Impact assessment for breaking changes

---

## 7. Common Library Development

### 7.1 Library Categories

#### Utility Libraries
- **adcb-common-utils-lib**: General utilities
- **adcb-validation-lib**: Business validation rules
- **adcb-encryption-lib**: Encryption/decryption utilities

#### Integration Libraries
- **adcb-kafka-lib**: Messaging abstractions
- **adcb-rest-client-lib**: HTTP client utilities
- **adcb-database-lib**: Database access patterns

#### Security Libraries
- **mib-jwt-lib**: JWT token handling
- **mib-audit-lib**: Audit logging
- **mib-oauth-lib**: OAuth integration

### 7.2 Library Development Standards

#### API Design
- Minimal and focused APIs
- Backward compatibility guaranteed
- Clear separation of public/internal APIs
- Auto-configuration for Spring Boot integration

#### Documentation Requirements
- Comprehensive README with examples
- JavaDoc for all public APIs
- Migration guides for version updates
- Sample projects demonstrating usage

### 7.3 Library Release Process

#### Versioning Strategy
- Semantic versioning (MAJOR.MINOR.PATCH)
- Pre-release versions for testing
- Long-term support for major versions

#### Publishing Pipeline
- Automated testing on multiple environments
- Security scanning and vulnerability assessment
- Publication to GitHub Packages
- Update BOM with new versions

---

## 8. Documentation Standards

### 8.1 Code Documentation

#### JavaDoc Requirements
- All public classes and methods documented
- Include `@param`, `@return`, `@throws` annotations
- Business context and usage examples
- `@since` tags for version tracking

#### Documentation Template
```java
/**
 * Service for managing customer banking profiles.
 * 
 * Handles customer creation, updates, and retrieval
 * according to ADCB business rules.
 * 
 * @author Development Team
 * @version 1.2.0
 * @since 2024-01-15
 */
public class CustomerProfileService {
    /**
     * Creates new customer with validation.
     * 
     * @param request Customer creation data
     * @return Created customer with assigned ID
     * @throws ValidationException if data invalid
     * @since 1.0.0
     */
    public Customer createCustomer(CreateCustomerRequest request) {
        // Implementation
    }
}
```

### 8.2 Repository Documentation

#### README Structure
- Project overview and purpose
- Technology stack and dependencies
- Setup and configuration instructions
- API documentation links
- Testing guidelines
- Deployment instructions
- Contributing guidelines
- Support and contact information

#### Architecture Decision Records (ADRs)
- Store in `docs/adr/` directory
- Document significant architectural decisions
- Include context, decision, and consequences
- Number sequentially (`001-decision-title.md`)

### 8.3 API Documentation

#### OpenAPI Specifications
- Generate from code annotations
- Publish to internal developer portal
- Include examples and use cases
- Version alongside service releases

---

## 9. CI/CD Pipeline Standards

### 9.1 Build Pipeline

#### Pipeline Stages
- **Compile**: Gradle clean build
- **Test**: Unit and integration tests
- **Quality**: SonarQube analysis, Spotbugs
- **Security**: Trivy vulnerability scanning
- **Package**: Docker image creation
- **Publish**: Artifact publication

#### Quality Gates
- Test coverage â‰¥ 70%
- Zero critical security vulnerabilities
- Code duplication < 10%
- Technical debt ratio < 5%

### 9.2 Deployment Pipeline

#### Environment Progression
- **Development**: Automatic deployment on develop merge
- **Staging**: Manual promotion with approval
- **Production**: Manual deployment with dual approval

#### Deployment Strategy
- Blue-green deployment for zero downtime
- Canary releases for high-risk changes
- Automated rollback on health check failures

### 9.3 Infrastructure as Code

#### Kubernetes Manifests
- Helm charts for all services
- Environment-specific values files
- Resource limits and requests defined
- Health checks and probes configured

#### GitOps Workflow
- ArgoCD for automated deployment
- Separate config repositories
- Declarative infrastructure management

---

## 10. Security & Compliance

### 10.1 Secrets Management

#### No Secrets in Code
- Use AWS Secrets Manager
- Environment variables for configuration
- Pre-commit hooks to prevent secrets
- Regular secret rotation

#### Access Control
- IAM roles for service accounts (IRSA)
- Principle of least privilege
- Regular access reviews

### 10.2 Security Scanning

#### Automated Security Checks
- Dependency vulnerability scanning
- Container image scanning
- Static code analysis (SonarQube)
- Dynamic security testing

### 10.3 Compliance Requirements

#### Audit Logging
- All business operations logged
- Structured JSON logging format
- Correlation IDs for tracing
- Secure log storage and retention

---

## 11. Monitoring & Observability

### 11.1 Logging Standards

#### Structured Logging
- JSON format for all logs
- Standard fields: timestamp, level, service, correlation-id
- Business event logging
- Error and exception logging

### 11.2 Metrics Collection

#### Application Metrics
- JVM metrics (heap, GC, threads)
- Business metrics (transactions, errors)
- Custom metrics for key operations
- Prometheus format export

### 11.3 Distributed Tracing

#### OpenTelemetry Integration
- Trace context propagation
- Service dependency mapping
- Performance bottleneck identification

---

## 12. Testing Guidelines

### 12.1 Testing Strategy

#### Test Pyramid
- **Unit Tests**: 70% of total tests
- **Integration Tests**: 20% of total tests
- **End-to-End Tests**: 10% of total tests

#### Testing Frameworks
- JUnit 5 for unit testing
- TestContainers for integration testing
- MockWebServer for external service mocking
- WireMock for API contract testing

### 12.2 Test Organization

#### Test Structure
- Follow same package structure as main code
- Separate test utilities and fixtures
- Shared test configuration in test resources

#### Test Data Management
- Test-specific databases
- Data cleanup after tests
- Repeatable and isolated tests

---

## 13. Performance & Scalability

### 13.1 Performance Standards

#### Response Time Targets
- API response time < 500ms (95th percentile)
- Database query time < 100ms
- External service calls < 2 seconds

#### Throughput Requirements
- Handle 1000 requests per second per service
- Scale horizontally based on load
- Circuit breakers for fault tolerance

### 13.2 Resource Management

#### JVM Configuration
- Appropriate heap size settings
- GC tuning for low latency
- Connection pool optimization

#### Database Optimization
- Proper indexing strategy
- Query performance monitoring
- Connection pool sizing

---

## Appendices

### Appendix A: Tool Recommendations

#### Development Tools
- IntelliJ IDEA Ultimate (preferred)
- Docker Desktop
- Postman for API testing
- DBeaver for database management

#### CLI Tools
- kubectl for Kubernetes management
- eksctl for EKS operations
- Helm for package management
- AWS CLI for cloud operations

### Appendix B: Reference Links

#### Internal Resources
- ADCB Developer Portal: [internal-link]
- GitHub Organization: [github-link]
- Confluence Space: [confluence-link]
- Slack Channels: #microservices-dev

#### External Resources
- Spring Boot Documentation
- Kubernetes Documentation
- Docker Best Practices
- AWS EKS User Guide

---

**Note:** For sample code, `.editorconfig`, and supporting assets/templates, refer to repository attachments and supplementary documentation as referenced throughout this guide.